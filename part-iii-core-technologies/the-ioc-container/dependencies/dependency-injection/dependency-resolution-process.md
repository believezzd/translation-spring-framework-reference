##### Dependency resolution process

容器是按照如下的方式来处理bean的依赖的:

- ApplicationContext根据配置元数据对所有的bean的描述进行初始化。配置元数据可以通过XML、Java代码或注解方式提供。

- 对于每一个bean来说，依赖可以表现为属性的形式，构造器参数或静态工厂方法的参数，而不是使用普通的构造器。在bean被创建时依赖会被提供。

- 每一个属性或构造器参数就是一个可以注入的值或者会被容器中其他的bean使用。

- 每一个属性或构造器参数会从他指定的形式转换为其实际的类型。默认情况下，spring有能力将string类型的值转换为所有内置的类型，如int、long、String、boolean等等。

在spring容器被创建时，容器就会校验每一个bean的配置合法性。然而，有些bean的属性直到bean被创建才会被设置。单例模式下的bean默认情况下会在容器被创建时先被初始化。范围的定义见7.5章节“Bean的范围”。另外，bean只有被需要的时候才会被创建。一个bean的创建可能会导致他依赖的bean被创建。在依赖中不匹配的resolution将会在后面展示，例如受影响的bean第一次被创建。

>循环依赖
>如果你使用构造器依赖，可能会出现无法处理的循环依赖的情况。
>例如，Class A依赖于Class B的实例通过构造器注入，并且Class B也需要Class A的实例，通过构造器注入。如果你这样配置A类和B类，spring IOC容器在运行时会发现循环注入，然后抛出BeanCurrentlyInCreationException。
>一种可行的解决方案是在一些类的源代码中通过使用set方法来实现而不是使用构造器。或者避免构造器注入而只是使用set方法注入。换句话说，尽管不推荐，但是你可以使用set方法注入来处理循环依赖的问题。
>不像典型的例子（没有循环依赖的情况），A和B的循环依赖才能完全初始化就像（一个典型的鸡和鸡蛋的故事）。

你可以相信spring用来做对的事。他可以检测配置问题，例如依赖一个不存在的bean或循环依赖在容器加载的时候。当bean被创建时，spring尽可能晚的设置属性和处理依赖。这就意味着一个已经成功加载的spring容器可以在创建bean时发现一个问题的情况下产生一个异常。例如，抛出一个丢失或非法属性的异常。ApplicationContext默认对单例进行预先实例化是为了延迟某些配置问题的可见性。在ApplicationContext创建的时候发现配置问题而不是在创建之后当bean被需要创建的时候去花费时间和内存。你仍然可以覆盖默认的行为，使得单例的bean可以延迟初始化， 而不是提前初始化。

如果没有循环注入的存在，当一个组合bean被注入一个依赖bean时，每一个组合bean被注入的时间都晚于依赖bean。这就意味着如果bean A依赖于bean B，spring的IOC容器将先配置bean B，然后在调用bean A的set方法。也就是说，bean被创建（如果不是提前初始化的单例bean），他的依赖被设置，然后生命周期方法被调用（如配置的init方法或InitializingBean的回调方法）