#### Glue code and the evil singleton

最好将大部分应用代码实现成依赖注入的方式，当这些代码在spring的ioc容器外部时，有独立的依赖通过容器当他们创建的时候并且没有意识到容器的存在。然而，对于小的粘合层代码有时需要和其他代码耦合，你有时需要单例（或准单例）风格来访问spring的ioc容器。例如，第三方代码或许视图直接创建一个新的object（使用Class.forName的形式），不在从spring的ioc容器中获得这些object。如果通过第三方代码创建的object是代理使用单例的风格访问spring的ioc容器来获得被委托的真正object，那么反转注入风格依然是代码的重要部分（object来源自容器外）。大部分代码依然不知道容器的存在及他们是如何被访问的，并且和其他的代码是解耦的，有很多的好处。EJB可以使用stub或代理访问普通的Java实现object，从spring的ioc容器中获得。spring的ioc容器理想上不是必须是单例的，对于内存的使用是不现实或初始化次数（当在spring的ioc容器中施一公类似于Hibernate的SessionFactory），对于每个bean使用非单例的spring的ioc容器。

查看应用上下文在服务定位器模式在有时是唯一的选项用于访问spring管理的组件，例如在EJB2.1环境中或当你希望共享一个单独的ApplicationContext作为一个WebApplicationContexts的父类，通过WAR文件。在这种情况你应该使用单元类ContextSingletonBeanFactoryLocator定位在spring的小组博客中讨论的。