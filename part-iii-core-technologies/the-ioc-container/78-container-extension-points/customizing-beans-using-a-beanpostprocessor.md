#### Customizing beans using a BeanPostProcessor

BeanPostProcessor接口定义了回调方法，你可以实现这个接口并提供自己的实现集成逻辑（或者覆盖容器中默认的实现）、依赖处理逻辑或其他的。如果你希望在spring容器完成初始化、配置和初始化bean之后做一些逻辑处理，你可以实现一个或多个BeanPostProcessor实现。

你可以配置多个BeanPostProcessor实例，并且你可以可控制在这些BeanPostProcessors中执行设置属性的顺序。如果BeanPostProcessor实现了Ordered接口，你可以设置这些属性。如果你实现自己的BeanPostProcessor，你需要考虑实现Ordered接口。更多的细节，见BeanPostProcessor和Ordered的javadocs。你也可以参考下面的BeanPostProcessors的编程注册。

>**Note**

> BeanPostProcessors操作一个bean（或object）的实例，简单点说，spring的IOC容器在完成初始化之后BeanPostProcessors会完成他的工作。

> BeanPostProcessors的作用域是每个容器。这个只取决于你正在使用的容器层级。如果你在一个容器中定义了BeanPostProcessor，他将会只在那个特定的容器中起作用。换句话说，一个容器中的BeanPostProcessor不会对另一个容器起作用，即便两个容器是相同的继承关系。

>需要改变实际bean的定义（例如，定义bean的蓝图），你需要根据需要像章节7.8.2“使用BeanPostProcessor来自定义配置元数据”的描述一样来使用BeanPostProcessor。

org.springframework.beans.factory.config.BeanPostProcessor接口有两个回调方法。当一个类被注册为一个容器的post-processor，对于这个容器创建的所有bean，每个bean的初始化方法（例如InitializingBean的afterPropertiesSet方法和任何被定义的init方法）结束前，在容器初始化方法之后，post-processor都会从容器中获得回调方法。post-processor可以对bean的实例做任何处理，包括忽略回调方法的完成。一个bean的post-processor通常检查回调接口或使用代理来包裹bean。一些spring的AOP基础组件类实现了bean的post-processor用于处理代理包裹逻辑。

ApplicationContext自动的探测bean被配置元数据定义成实现BeanPostProcessor接口。ApplicationContext将这些bean注册成post-processor以让他们可以在bean创建之后被调用。post-processor的bean可以像其他的bean一样定义在容器中。

注意当使用@Bean修饰的工厂方法来定义BeanPostProcessor的类时，工厂方法的返回值应该实现类本身或至少实现org.springframework.beans.factory.config.BeanPostProcessor接口，明确定义bean的post-processor特性。否则，ApplicationContext不能在完全创建之前通过类型自动探测到。BeanPostProcessor需要被提前初始化以用于其他上下文bean的初始化，早的类型探测是关键的。

> **Programmatically registering BeanPostProcessors**

> 建议BeanPostProcessor的注册方法是通过ApplicationContext的自动探测（同上面描述的），他也可以通过ConfigurableBeanFactory使用addBeanPostProcessor方法来编程实现。如果需要评价条件逻辑在注册之前或在继承的上下文中拷贝bean的post processor时是很有用的。注意，然而编程添加BeanPostProcessors不可以respect Ordered接口。这里注册的顺序决定了运行的顺序。注意即使明确定义了顺序，编程注册的BeanPostProcessors比自动探测注册的BeanPostProcessors要提早运行。

> **BeanPostProcessors and AOP auto-proxying**

> 实现BeanPostProcessor接口的类在容器中是特殊对待的。所有的BeanPostProcessors和这些bean引用的会在启动时直接初始化，作为ApplicationContext的特殊启动部分。然后，所有的BeanPostProcessors被注册并且应用于容器中的其他bean。因为AOP自动代理实现了BeanPostProcessor自身，所以BeanPostProcessors和他依赖的bean不适合于自动代理，不要在切面中包含他们

> 对于任何这样的bean，你应该查看日志会看到“Bean foo不适合被所有的BeanPostProcessor接口处理（例如，不适合自动代理）”

> 

以下的例子展示了如何编程、注册和使用 BeanPostProcessors 在 ApplicationContext 中